var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"Here is a quick-start guide for people familiar with ADI and experience using tools like VIP or PyKLIP.","category":"page"},{"location":"gettingstarted/#Expected-Data-Formats-1","page":"Getting Started","title":"Expected Data Formats","text":"","category":"section"},{"location":"gettingstarted/#ADI-Cube-1","page":"Getting Started","title":"ADI Cube","text":"","category":"section"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"For standard ADI data, we store the values in a 3-dimensional array, where the first dimension is temporal, and the remaining dimensions are pixel coordinates. This is how most ADI data are stored on disk (typically in FITS files) and allow specifying operations like a tensor.","category":"page"},{"location":"gettingstarted/#Algorithms-1","page":"Getting Started","title":"Algorithms","text":"","category":"section"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"The following algorithms are implemented:","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"Median Subtraction\nPCA\nNMF\nGreeDS","category":"page"},{"location":"gettingstarted/#Processing-Patterns-1","page":"Getting Started","title":"Processing Patterns","text":"","category":"section"},{"location":"gettingstarted/#Full-Reduction-1","page":"Getting Started","title":"Full Reduction","text":"","category":"section"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"Given an algorithm alg, we can fully process ADI data by calling alg like a function","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"julia> alg = PCA(5)\n\njulia> resid = alg(cube, angles)","category":"page"},{"location":"gettingstarted/#Reduction-Process-1","page":"Getting Started","title":"Reduction Process","text":"","category":"section"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"The process for producing the flat, residual frame follows this general workflow","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"Create a cube of the speckle approximation, S\nSubtract S from the data cube to create the residual cube R\nDerotate R frame-by-frame according to the parallactic angle\nCollapse the derotated R","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"In ADI.jl this process looks like this:","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"using HCIToolbox: collapse, derotate\nusing ADI: reconstruct, PCA\n\ncube, angles = # load data\nS = reconstruct(PCA(10), cube, angles)\nR = cube .- S\nR_derotate = derotate(R, angles)\nresid = collapse(R_derotate)\n# or, more succinctly\nresid = collapse(R, angles)","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"Notice how the only part of this specific to the algorithm is reconstruct? This lets us have the super-compact functional form from above without having to copy the common code for each algorithm.","category":"page"},{"location":"gettingstarted/#Decomposition-1","page":"Getting Started","title":"Decomposition","text":"","category":"section"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"For certain types of ADI algorithms, a convenient linear form is used for the speckle approximation","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"mathbfS approx mathbfw cdot mathbfA","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"Algorithms which share this attribute share the abstract type ADI.LinearAlgorithm, and we can retrieve these two matrices via decompose.","category":"page"},{"location":"gettingstarted/#","page":"Getting Started","title":"Getting Started","text":"using ADI: decompose, reconstruct, PCA\ncube, angles = # load data\nA, w = decompose(PCA(10), cube, angles)\nS = reconstruct(PCA(10), A, w)\nS == w * A\n# output\ntrue","category":"page"},{"location":"metrics/#Metrics-1","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"metrics/#API/Reference-1","page":"Metrics","title":"API/Reference","text":"","category":"section"},{"location":"metrics/#","page":"Metrics","title":"Metrics","text":"Modules = [ADI.Metrics]","category":"page"},{"location":"metrics/#ADI.Metrics","page":"Metrics","title":"ADI.Metrics","text":"ADI.Metrics\n\nThis module provides code for analyzing the results from ADI in a way that is interpretable statistically. Some of the key functionalities are signal-to-noise, significance, the receiver operating characteristic, and the contrast curve.\n\n\n\n\n\n","category":"module"},{"location":"metrics/#ADI.Metrics.contrast_curve-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}","page":"Metrics","title":"ADI.Metrics.contrast_curve","text":"contrast_curve(alg,\n               cube,\n               angles,\n               psf,\n               args...;\n               fwhm,\n               sigma=5,\n               starphot=Metrics.estimate_starphot(cube, fwhm),\n               nbranch=1,\n               theta=0,\n               inner_rad=1,\n               fc_rad_sep=3,\n               snr=100,\n               k=2,\n               kwargs...)\n\nCalculate the throughput-calibrated contrast. This first processes the algorithmic throughput by injecting instances of psf into cube. These are processed through alg and the ratio of the recovered flux to the injected flux is calculated. These companions are injected in resolution elements across the frame, which can be changed via the various keyword arguments.\n\nThe throughput can only be calculated for discrete resolution elements, but we typically want a much smoother curve. To accomplish this, we measure the noise (the standard deviation of all resolution elements in an annulus at a given radius) for every pixel in increasing radii. We then interpolate the throughput to this grid and return the subsampled curves.\n\nFields\n\ndistance - The radial distance (in pixels) for each measurement\ncontrast - The Gaussian sensitivity\ncontrast_corr - The Student-t sensitivity\nnoise - The noise measured for each distance\nthroughput - The throughput measured for each distance.\n\nKeyword Arguments\n\nsigma - The confidence limit in terms of Gaussian standard deviations\nstarphot - The flux of the star. By default calculates the flux in the central core.\nnbranch - number of azimuthal branches to use\ntheta - position angle of initial branch\ninner_rad - position of innermost planet in FWHM\nfc_rad_sep - the separation between planets in FWHM for a single reduction\nsnr - the target signal to noise ratio of the injected planets\nk - The order of the BSpline used for subsampling the throughput\n\ntip: Tip\nIf you prefer a tabular format, simply pipe the output of this function into any type supporting the Tables.jl interface, e.g.contrast_curve(alg, cube, angles, psf; fwhm=fwhm) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"metrics/#ADI.Metrics.detectionmap-Union{Tuple{T}, Tuple{Any,AbstractArray{T,2},Any}} where T","page":"Metrics","title":"ADI.Metrics.detectionmap","text":"detectionmap([method=snr], data, fwhm; fill=0)\n\nParallel implementation of arbitrary detection mapping applied to each pixel in the input image. Any invalid values will be set to fill.\n\nThe following methods are provided in the Metrics module:\n\nsnr - signal-to-noise ratio (S/N) using student-t statistics to account for small sample penalty.\nsignificance - Gaussian signifance using student-t statistics to account for samll sample penalty.\n\ntip: Tip\nThis code is automatically multi-threaded, so be sure to set JULIA_NUM_THREADS before loading your runtime to take advantage of it!\n\n\n\n\n\n","category":"method"},{"location":"metrics/#ADI.Metrics.noise-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"Metrics","title":"ADI.Metrics.noise","text":"noise(data, position, fwhm)\n\nCalculate the statistical noise for a test point at position using apertures of diameter fwhm in a residual frame.\n\nUses the standard deviation of the apertures in the entire annulus. This is distinct from the snr noise calculation, which defines a confidence interval using student-t statistics. This means you cannot simply create a noise map and divide it from the signal to create an equivalent S/N map.\n\n\n\n\n\n","category":"method"},{"location":"metrics/#ADI.Metrics.significance-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"Metrics","title":"ADI.Metrics.significance","text":"significance(data, position, fwhm)\n\nCalculates the Gaussian significance from the signal-to-noise ratio (SNR, S/N) for a test point at position using apertures of diameter fwhm in a residual frame.\n\nThe Gaussian signifiance is calculated from converting the SNR confidence limit from a student t distribution to a Gaussian via\n\ntextsig(textSNR) = Phi^-1leftint_0^textSNRt_nu(x)dxright\n\nwhere the degrees of freedom nu is given as 2pi r  Gamma - 2 where r is the radial distance of each pixel from the center of the frame.\n\nSee Also\n\nsnr\n\n\n\n\n\n","category":"method"},{"location":"metrics/#ADI.Metrics.snr-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"Metrics","title":"ADI.Metrics.snr","text":"snr(data, position, fwhm)\n\nCalculate the signal to noise ratio (SNR, S/N) for a test point at position using apertures of diameter fwhm in a residual frame.\n\nUses the method of Mawet et al. 2014 which includes penalties for small sample statistics. These are encoded by using a student's t-test for calculating the SNR.\n\nnote: Note\nSNR is not equivalent to significance, use significance instead\n\n\n\n\n\n","category":"method"},{"location":"metrics/#ADI.Metrics.throughput-Union{Tuple{T}, Tuple{Any,AbstractArray{T,3},Any,Any,Vararg{Any,N} where N}} where T","page":"Metrics","title":"ADI.Metrics.throughput","text":"throughput(alg,\n           cube,\n           angles,\n           psf,\n           args...;\n           fwhm,\n           nbranch=1,\n           theta=0,\n           inner_rad=1,\n           fc_rad_sep=3,\n           snr=100,\n           kwargs...)\n\nCalculate the throughput of alg by injecting fake companions into cube and measuring the relative photometry of each companion in the reduced frame. Any additional args or kwargs will be passed to alg when it is called.\n\nKeyword Arguments\n\nnbranch - number of azimuthal branches to use\ntheta - position angle of initial branch\ninner_rad - position of innermost planet in FWHM\nfc_rad_sep - the separation between planets in FWHM for a single reduction\nsnr - the target signal to noise ratio of the injected planets\n\n\n\n\n\n","category":"method"},{"location":"metrics/#ADI.Metrics.estimate_starphot-Tuple{AbstractArray{T,2} where T,Any}","page":"Metrics","title":"ADI.Metrics.estimate_starphot","text":"Metrics.estimate_starphot(cube, fwhm)\nMetrics.estimate_starphot(frame, fwhm)\n\nSimple utility to estimate the stellar photometry by placing a circular aperture with fwhm diameter in the center of the frame. If a cube is provided, first the median frame will be found.\n\n\n\n\n\n","category":"method"},{"location":"api/#API/Reference-1","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"For now, here is a dump of all documented functions and types.","category":"page"},{"location":"api/#Index-1","page":"API/Reference","title":"Index","text":"","category":"section"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#API/Reference-2","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"ADI.ADIAlgorithm\nADI.LinearAlgorithm\nreconstruct\ndecompose","category":"page"},{"location":"api/#ADI.ADIAlgorithm","page":"API/Reference","title":"ADI.ADIAlgorithm","text":"ADI.ADIAlgorithm <: Function\n\nThis abstract type is used for defining ADI algorithms. See the extended help (??ADIAlgorithm) for interface details.\n\nExtended help\n\nInterface\n\nTo extend ADIAlgorithm you may implement the following\n\nfunction default description\nreconstruct  Subroutine for creating the full reconstructed cube with the PSF\n(::ADIAlgorithm) subtracts output of reconstruct, then derotates and collapses Subroutine for returning the reduced residual cube\n\n\n\n\n\n","category":"type"},{"location":"api/#ADI.LinearAlgorithm","page":"API/Reference","title":"ADI.LinearAlgorithm","text":"ADI.LinearAlgorithm <: ADI.ADIAlgorithm\n\nThis abstract type is used for defining linear ADI algorithms. See the extended help (??LinearAlgorithm) for interface details.\n\nExtended help\n\nInterface\n\nTo extend LinearAlgorithm you may implement the following\n\nfunction default description\ndecompose  Subroutine for fitting the linear basis and coefficients as unrolled matrices\nreconstruct Computes the inner product of the design matrix and weights from decompose Subroutine for creating the full reconstructed cube with the PSF\n(::LinearAlgorithm) subtracts output of reconstruct, then derotates and collapses Subroutine for returning the reduced residual cube\n\n\n\n\n\n","category":"type"},{"location":"api/#ADI.reconstruct","page":"API/Reference","title":"ADI.reconstruct","text":"reconstruct(::ADIAlgorithm, cube, angles, [cube_ref]; kwargs...)\n\nReconstruct the PSF approximation for the given algorithm, using cube_ref as the reference cube if given.\n\n\n\n\n\n","category":"function"},{"location":"api/#ADI.decompose","page":"API/Reference","title":"ADI.decompose","text":"ADI.decompose(::LinearAlgorithm, cube, angles, [cube_ref]; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"sdi/#SDI-1","page":"SDI","title":"SDI","text":"","category":"section"},{"location":"sdi/#","page":"SDI","title":"SDI","text":"ADI.SDIAlgorithm","category":"page"},{"location":"sdi/#ADI.SDIAlgorithm","page":"SDI","title":"ADI.SDIAlgorithm","text":"ADI.SDIAlgorithm <: ADI.ADIAlgorithm\n\nSpectral differential imaging (SDI) algorithms. These work on 4-D SDI tensors. To use these algorithms, simply treat them like functions\n\n(::SDIAlgorithm)(data::AbstractArray{T,4}, angles, scales; kwargs...)\n(::SDIAlgorithm)(data::AbstractArray{T,4}, angles, data_ref, scales; kwargs...)\n\nAlgorithms\n\nThe current SDI implementations are\n\nSingleSDI\nDoubleSDI\n\n\n\n\n\n","category":"type"},{"location":"sdi/#API/Reference-1","page":"SDI","title":"API/Reference","text":"","category":"section"},{"location":"sdi/#","page":"SDI","title":"SDI","text":"SingleSDI\nDoubleSDI","category":"page"},{"location":"sdi/#ADI.SingleSDI","page":"SDI","title":"ADI.SingleSDI","text":"SingleSDI(alg)\n\nA wrapper algorithm for spectral differential imaging (SDI) data reduced in a single pass. This means that each channel will be scaled and then concatenated together, so an SDI tensor (nλ, nf, y, x) becomes a stack (nλ * nf, y, x) which is processed by the underlying alg like ADI data.\n\ntip: Tip\nSingleSDI is the default SDI mode. This means instead of writingSingleSDI(PCA(15))(data, angles, scales)you can just writePCA(15)(data, angles, scales)\n\n\n\n\n\n","category":"type"},{"location":"sdi/#ADI.DoubleSDI","page":"SDI","title":"ADI.DoubleSDI","text":"DoubleSDI(alg)\nDoubleSDI(alg_spec, alg_temp)\n\nA wrapper algorithm for spectral differential imaging (SDI) data reduced in two passes. The first pass uses alg_spec to reduce each spectral cube slice in the SDI tensor. Then, the spectral residual frames will be reduced using alg_temp, which will include the derotation and final combination.\n\nExamples\n\njulia> data, angles, scales = # load data...\n\n# Median subtraction for each spectral slice,\n# GreeDS{PCA} subtraction on spectral residual cube\njulia> res = DoubleSDI(Median(), GreeDS(15))(data, angles, scales)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/median/#med-1","page":"Median","title":"Median","text":"","category":"section"},{"location":"algorithms/median/#API/Reference-1","page":"Median","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/median/#","page":"Median","title":"Median","text":"Median","category":"page"},{"location":"algorithms/median/#ADI.Median","page":"Median","title":"ADI.Median","text":"Median()\n\nClassic PSF subtraction using the median of entire data cube.\n\nReferences\n\nMarois et al. 2006 Angular Differential Imaging: A Powerful High-Contrast Imaging Technique\n\n\n\n\n\n","category":"type"},{"location":"algorithms/nmf/#nmf-1","page":"NMF","title":"NMF","text":"","category":"section"},{"location":"algorithms/nmf/#API/Reference-1","page":"NMF","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/nmf/#","page":"NMF","title":"NMF","text":"NMF","category":"page"},{"location":"algorithms/nmf/#ADI.NMF","page":"NMF","title":"ADI.NMF","text":"NMF(;ncomps=nothing) <: LinearAlgorithm\n\n\n\n\n\n","category":"type"},{"location":"algorithms/pca/#pca-1","page":"PCA","title":"PCA","text":"","category":"section"},{"location":"algorithms/pca/#API/Reference-1","page":"PCA","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/pca/#","page":"PCA","title":"PCA","text":"PCA\nTPCA","category":"page"},{"location":"algorithms/pca/#ADI.PCA","page":"PCA","title":"ADI.PCA","text":"PCA(;ncomps=nothing, pratio=1) <: LinearAlgorithm\n\nUse principal components analysis (PCA) to form a low-rank orthonormal basis of the input. Uses deterministic singular-value decomposition (SVD) to decompose data.\n\nIf ncomps is nothing, it will be set to the number of frames in the reference cube when processed.\n\nReferences\n\nSoummer, Pueyo, and Larkin (2012) \"Detection and Characterization of Exoplanets and Disks Using Projections on Karhunen-Loève Eigenimages\"\n\nImplements\n\ndecompose\n\n\n\n\n\n","category":"type"},{"location":"algorithms/pca/#ADI.TPCA","page":"PCA","title":"ADI.TPCA","text":"TPCA(;ncomps=nothing) <: LinearAlgorithm\n\nPerform principal components analysis (PCA) using truncated SVD (TSVD; provided by TSVD.jl) instead of deterministic SVD. This is often faster thant PCA but is non-determinstic. We find the differences unnoticable in practice.\n\nIf ncomps is nothing, it will be set to the number of frames in the reference cube when processed.\n\nImplements\n\ndecompose\n\nSee Also\n\nPCA, TSVD.tsvd\n\n\n\n\n\n","category":"type"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"EditURL = \"https://github.com/JuliaHCI/ADI.jl/blob/master/examples/hr8799.jl\"","category":"page"},{"location":"examples/hr8799/#ADI-Reduction-of-HR8799-1","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"","category":"section"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"This example will walk through a full reduction and some analysis of HR8799 in order to show the basic usage of ADI.jl for high-contrast imaging. HR8799 is a known exoplanet host with many publications regarding the direct images of 4 sub-stellar companions.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"What will not be covered in this example are the basics of Julia, the fine details of ADI post-processing, or any reference documentation.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"","category":"page"},{"location":"examples/hr8799/#Setup-1","page":"ADI Reduction of HR8799","title":"Setup","text":"","category":"section"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Let's begin by importing the necessary libraries","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"using ADI\nusing DataFrames\nusing HCIDatasets: HR8799\nusing HCIToolbox\nusing Plots\n\n# set up plotting\nfunction imshow(img, args...; kwargs...)\n    ylim = extrema(axes(img, 1))\n    xlim = extrema(axes(img, 2))\n    heatmap(img, args...; aspect_ratio=1, xlim=xlim, ylim=ylim, kwargs...)\nend;\nnothing #hide","category":"page"},{"location":"examples/hr8799/#Data-Reduction-1","page":"ADI Reduction of HR8799","title":"Data Reduction","text":"","category":"section"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Here we load the data for HR8799 from Keck NIRC2/Vortex Coronagraph. You may be prompted to download the data; see HCIDatasets.jl for more details.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"cube = HR8799[:cube]\nangles = HR8799[:pa];\nnothing #hide","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"To reduce the data, we need an algorithm. In ADI.jl we currently have median subtraction, PCA, NMF, and fixed-point GreeDS. These algorithms are treated as \"objects\" in the sense that we initialize them with options and then pass them around inside the ADI.jl framework to retrieve the results we want.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"The usage for fitting the speckle estimate, projecting and subtracting this estimate from the target cube, and derotating and collapsing the residual all are encompassed by calling the algorithm as a function. To try out different algorithms, all you should have to do is change this one line and re-run the remaining code.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"alg = PCA(10) # 10 components\nreduced = alg(cube, angles)\nimshow(reduced)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"You may want to mask out an interior angle since there is an inner limit for our signal to be a real planet (as opposed to systematics from the optical system or noise). We can mask out an interior circle either before processing with the algorithm or afterwards using HCIToolbox.mask_circle.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"mask_cube = mask_circle(cube, 16)\nmask_reduced = alg(mask_cube, angles)\nimshow(mask_reduced)","category":"page"},{"location":"examples/hr8799/#S/N-and-Significance-Maps-1","page":"ADI Reduction of HR8799","title":"S/N and Significance Maps","text":"","category":"section"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Now that we have our reduced frame, let's look at the signal-to-noise ratio (SNR, S/N). We use the exact S/N calculation here, implemented in a fast, multi-threaded framework. In order to measure the S/N, though, we need the effective FWHM of our instrument. Normally, we would measure this from an off-axis (or non-coronagraphic) PSF, but for simplicity I'll hard-code a value.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"fwhm = 8.637\nsnrmap = detectionmap(snr, reduced, fwhm)\nimshow(snrmap)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"If we want to get the statistical significance, we need to convert from the student-t confidence interval derived in the S/N to the Gaussian significance. We can accomplish this by calling","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"sigmap = detectionmap(significance, reduced, fwhm)\nimshow(sigmap)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Now, lets do some very basic frequentist planet detection by thresholding this significance","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"sigmap_cutoff = @. sigmap > 5\nimshow(sigmap_cutoff)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"looks like we've successfully pulled out HR8799b,c,d, and e from the data!","category":"page"},{"location":"examples/hr8799/#Contrast-Curve-1","page":"ADI Reduction of HR8799","title":"Contrast Curve","text":"","category":"section"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"We are also interested in analyzing how the algorithm affects our data, especially calculating the throughput and the contrast curve. These measure, effectively, how much signal is lost during the subtraction step of the algorithm and give us an idea of what the limits of our algorithm are with our data.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Before we move on, we need to create a PSF model for our data. HCIToolbox.Kernels includes some simple functional PSFs in the absence of an empirical PSF.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"psf = Kernels.Normal(fwhm)\nimshow(construct(psf, (31, 31)))","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"and now we can calculate the 5σ contrast curve","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"cc = contrast_curve(alg, cube, angles, psf; fwhm=fwhm, nbranch=3) |> DataFrame\nhead(filter(row -> isfinite(row.contrast_corr), cc))","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"and lets plot it to see how we perform","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"plot(\n    cc[:distance],\n    [cc[:contrast_corr] cc[:contrast]],\n    ls=[:solid :dash],\n    c=1,\n    yscale=:log10,\n    label=[\"Student-t\" \"Gaussian\"],\n    ylabel=\"5-sigma contrast\",\n    xlabel=\"radius [px]\"\n)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Hmm, there's some pecularities! You'll notice pretty sever bumps indicating poor contrast in annuli where the 4 companions are! Because these companions are pretty significant (statistically) they will bias the contrast measurement.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"Typically you'd like to fit the companion signal and remove it in a maximum likelihood framework. For convenience here, though, I am going to create a cube from the speckle estimate, which should be free from companion signal. This is not a rigorous alternative, though, since this cube's noise will be whitened by the PCA process. It will be good enough to demonstrate the code, though.","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"no_comp_cube = reconstruct(alg, cube, angles)\nno_comp_reduced = alg(no_comp_cube, angles)\nimshow(no_comp_reduced)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"cc_no_comp = contrast_curve(alg, no_comp_cube, angles, psf; fwhm=fwhm, nbranch=3) |> DataFrame\nhead(cc_no_comp)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"plot(\n    cc_no_comp[:distance],\n    [cc_no_comp[:contrast_corr] cc_no_comp[:contrast]],\n    ls=[:solid :dash],\n    c=1,\n    yscale=:log10,\n    label=[\"Student-t\" \"Gaussian\"],\n    ylabel=\"5-sigma contrast\",\n    xlabel=\"radius [px]\"\n)","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"","category":"page"},{"location":"examples/hr8799/#","page":"ADI Reduction of HR8799","title":"ADI Reduction of HR8799","text":"This page was generated using Literate.jl.","category":"page"},{"location":"algorithms/greeds/#greeds-1","page":"GreeDS","title":"GreeDS","text":"","category":"section"},{"location":"algorithms/greeds/#API/Reference-1","page":"GreeDS","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/greeds/#","page":"GreeDS","title":"GreeDS","text":"GreeDS","category":"page"},{"location":"algorithms/greeds/#ADI.GreeDS","page":"GreeDS","title":"ADI.GreeDS","text":"GreeDS(alg=TPCA(); threshold=0.0, progress=true)\n\nPerforms the greedy disk subtraction (GreeDS) algorithm.\n\nThis method is an iterative approach to standard ADI reduction which seeks to minimize over-subtraction by constraining the low-rank matrix approximation from alg.\n\nFor large data cubes the iteration can cause slowdowns, so a progress bar is provided using the ProgressLogging API along with the progress keyword. It won't appear without a logging backend, such as TerminalLoggers.\n\nAlgorithms\n\nAlthough the original paper explicitly uses PCA, we allow use of any linear ADI algorithm that is characterized by ncomps. By default, uses PCA.\n\nReferences\n\nPairet et al. 2018 \"Reference-less algorithm for circumstellar disks imaging\"\nPairet et al. 2020 \"MAYONNAISE: a morphological components analysis pipeline for circumstellar disks and exoplanets imaging in the near infrared\"\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = ADI","category":"page"},{"location":"#ADI.jl-1","page":"Home","title":"ADI.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage) (Image: License)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: DOI)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A package for angular differential imaging (ADI) along with its variants, such as reference differential imaging (RDI) and spectral differential imaging (SDI).","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"From Julia enter Pkg mode","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia>]\n\n(@v1.5) pkg> add ADI","category":"page"},{"location":"#License-1","page":"Home","title":"License","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This work is distributed under the MIT \"expat\" license. See LICENSE for more information.","category":"page"}]
}
